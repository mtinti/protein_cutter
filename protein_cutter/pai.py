"""Pipeline to compute PAI"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_pai.ipynb.

# %% auto 0
__all__ = ['TEST_DATA', 'CONFIG_FILES', 'infile', 'fasta_dict', 'df_pep', 'df_prot', 'get_observable', 'add_pai']

# %% ../nbs/01_pai.ipynb 3
import matplotlib.pyplot as plt
from typing import Dict, Union
from pyteomics import parser
from tqdm import tqdm
from pyteomics import mass
from pathlib import Path
from Bio import SeqIO
import pandas as pd
import polars as pl
import numpy as np

from .core import digest_to_empai_set
from .core import collapse_empai_entries
from .core import flag_proprietary_peptides_from_set
from .core import flag_proprietary_from_pg
from .core import load_peptides_from_fasta
from .core import load_fasta

# %% ../nbs/01_pai.ipynb 4
from pathlib import Path
import os
import yaml
# Get the repository root
if 'GITHUB_WORKSPACE' in os.environ:
    # In GitHub Actions
    REPO_ROOT = Path(os.environ['GITHUB_WORKSPACE'])
else:
    # Local development - find repo root
    REPO_ROOT = Path.cwd()
    while not (REPO_ROOT / 'settings.ini').exists():
        if REPO_ROOT == REPO_ROOT.parent:
            REPO_ROOT = Path.cwd()  # Fallback
            break
        REPO_ROOT = REPO_ROOT.parent

TEST_DATA = REPO_ROOT / 'test_data'
CONFIG_FILES = REPO_ROOT / 'config_files'
print(f"Repo root: {REPO_ROOT}")
print(f"Test data dir: {TEST_DATA}")
print(f"Test data exists: {TEST_DATA.exists()}")

# %% ../nbs/01_pai.ipynb 5
with open(CONFIG_FILES / 'config.yaml', 'r') as stream:
    config = yaml.safe_load(stream)
print(config)   

# %% ../nbs/01_pai.ipynb 6
infile = TEST_DATA/'pipeline_test/prot.fa'
#infile = '../datasets/spectronaut_protein.fasta'
fasta_dict = load_fasta(infile)

# %% ../nbs/01_pai.ipynb 8
def get_observable(
    sequence: str,
    enzyme: str = 'trypsin_full') -> set[str]:
    """
    Get the set of observable peptides from in silico digestion.
    
    Performs in silico digestion of a protein sequence and returns
    the set of theoretically observable peptides. This is used as
    the denominator (N_observable) in PAI and emPAI calculations.
    
    Parameters
    ----------
    sequence : str
        Protein amino acid sequence to digest.
    enzyme : str
        Enzyme name for in silico digestion. Must be a key in
        protease_dict. Default is trypsin_full.
    
    Returns
    -------
    set of str
        Set of unique observable peptide sequences after digestion
        and filtering by m/z range.
    
    Notes
    -----
    The function applies the following constraints:
    
    - Zero missed cleavages (fully cleaved peptides only)
    - m/z range filter of 200 to 4000 Da
    - Collapsed entries to remove charge state duplicates
    
    """
    observable_peptides = collapse_empai_entries(
        digest_to_empai_set(
            sequence=sequence,
            enzyme=enzyme,
            missed_cleavages=0,
            mz_range=(200, 4000),
        )
    )
    return observable_peptides

# %% ../nbs/01_pai.ipynb 10
#infile = "../datasets/spectronaut_peptide_report.tsv"
infile = TEST_DATA/'pipeline_test/pep_report.tsv'
df_pep  = pl.read_csv(infile,separator='\t').to_pandas()
df_pep = df_pep[df_pep['PEP.NrOfMissedCleavages']==0]
df_pep.head()

# %% ../nbs/01_pai.ipynb 11
#infile = "../datasets/spectronaut_protein_report.tsv"
infile = TEST_DATA/'pipeline_test/prot_report.tsv'
df_prot = pl.read_csv(infile, separator='\t').to_pandas()
df_prot.head()

# %% ../nbs/01_pai.ipynb 14
def add_pai(
    prot_df_path: Union[str, Path],
    pep_df_path: Union[str, Path],
    fasta_path: Union[str, Path],
    output_path: Union[str, Path] = None,
    pg_in_prot: str = 'PG.ProteinGroups',
    pg_in_pep: str = 'PG.ProteinAccessions',
    missed_cleavages_col: str = 'PEP.NrOfMissedCleavages',
    pep_stripped_col: str = 'PEP.StrippedSequence',
    enzyme: str = 'trypsin_full',
    filter_missed_cleavages: bool = True,
) -> pd.DataFrame:
    """
    Calculate Protein Abundance Index (PAI) for each protein group.
    
    Computes the ratio of observed peptides to observable peptides for
    each protein, providing a measure of sequence coverage that normalizes
    for protein size. This metric is useful for distinguishing between
    peptide-level and protein-level evidence in proteomics experiments.
    
    Parameters
    ----------
    prot_df_path : str or Path
        Path to protein-level report file (TSV format).
    pep_df_path : str or Path
        Path to peptide-level report file (TSV format).
    fasta_path : str or Path
        Path to FASTA file containing protein sequences.
    output_path : str or Path or None
        Path for output file. If None, appends '.pai' before the
        extension of prot_df_path. Default is None.
    pg_in_prot : str
        Column name for protein groups in protein report.
        Default is PG.ProteinGroups.
    pg_in_pep : str
        Column name for protein accessions in peptide report.
        Default is PG.ProteinAccessions.
    missed_cleavages_col : str
        Column name for missed cleavages count in peptide report.
        Default is PEP.NrOfMissedCleavages.
    pep_stripped_col : str
        Column name for stripped peptide sequences.
        Default is PEP.StrippedSequence.
    enzyme : str
        Enzyme name for in silico digestion to calculate observable
        peptides. Default is trypsin_full.
    filter_missed_cleavages : bool
        If True, only consider peptides with zero missed cleavages
        for observed count. Default is True.
    
    Returns
    -------
    pd.DataFrame
        Protein report DataFrame with added pai column containing
        the ratio of observed to observable peptides.
    
    Notes
    -----
    The PAI (Protein Abundance Index) is calculated as:
    
        PAI = N_observed / N_observable
    
    Where:
    
    - N_observed: Unique peptides detected for the protein
    - N_observable: Theoretical peptides from in silico digestion
    
    This differs from emPAI which uses the exponential formula.
    PAI values range from 0 to 1, where higher values indicate
    better sequence coverage.
    
    The output file is saved as TSV with the same structure as
    the input protein report plus the pai column.
    
    """
    # Convert paths
    prot_df_path = Path(prot_df_path)
    pep_df_path = Path(pep_df_path)
    fasta_path = Path(fasta_path)
    
    # Validate input files exist
    for path, name in [(prot_df_path, "Protein report"), 
                       (pep_df_path, "Peptide report"), 
                       (fasta_path, "FASTA")]:
        if not path.exists():
            raise FileNotFoundError(f"{name} file not found: {path}")
    
    # Set default output path
    if output_path is None:
        output_path = prot_df_path.with_suffix('.pai.tsv')
    else:
        output_path = Path(output_path)
    
    # Ensure output directory exists
    output_path.parent.mkdir(parents=True, exist_ok=True)
    
    # Load data
    df_prot = pl.read_csv(prot_df_path, separator='\t').to_pandas()
    df_pep = pl.read_csv(pep_df_path, separator='\t').to_pandas()
    
    # Validate required columns
    for col, df, name in [
        (pg_in_prot, df_prot, "protein report"),
        (pg_in_pep, df_pep, "peptide report"),
        (pep_stripped_col, df_pep, "peptide report"),
    ]:
        if col not in df.columns:
            raise ValueError(f"Column '{col}' not found in {name}")
    
    if filter_missed_cleavages:
        if missed_cleavages_col not in df_pep.columns:
            raise ValueError(
                f"Column '{missed_cleavages_col}' not found in peptide report. "
                f"Set filter_missed_cleavages=False to skip this filter."
            )
        df_pep = df_pep[df_pep[missed_cleavages_col] == 0]
    
    # Load FASTA sequences
    fasta_dict = load_fasta(fasta_path)
    
    # Calculate PAI for each protein group
    pai_results = []
    
    for protein_group in df_prot[pg_in_prot]:
        # Get first protein in group
        protein_id = protein_group.split(';')[0]
        
        # Get sequence and clean it
        if protein_id not in fasta_dict:
            pai_results.append(float('nan'))
            continue
            
        sequence = fasta_dict[protein_id].replace('*', '')
        
        # Calculate observable peptides
        observable_peptides = get_observable(sequence, enzyme=enzyme)
        n_observable = len(observable_peptides)
        
        # Get observed peptides for this protein group
        mask = df_pep[pg_in_pep] == protein_group
        observed_peptides = set(df_pep.loc[mask, pep_stripped_col].unique())
        n_observed = len(observed_peptides)
        
        # Calculate PAI
        if n_observable > 0:
            pai = n_observed / n_observable
        else:
            pai = float('nan')
        
        pai_results.append(pai)
    
    # Add PAI column to DataFrame
    df_prot['pai'] = pai_results
    
    # Save results
    df_prot.to_csv(output_path, sep='\t', index=False)
    
    return df_prot
