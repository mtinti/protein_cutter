# core


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

``` python
print(1)
```

    1

------------------------------------------------------------------------

<a
href="https://github.com/mtinti/protein_cutter/blob/main/protein_cutter/core.py#L46"
target="_blank" style="float:right; font-size:smaller">source</a>

### load_fasta

>  load_fasta (fasta_path:Union[str,pathlib.Path])

*Load protein sequences from a FASTA file into a dictionary.*

Parses a FASTA file and returns a dictionary mapping protein identifiers
to their sequences.

<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 38%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>fasta_path</td>
<td>Union</td>
<td>Path to the FASTA file.</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>Dict</strong></td>
<td><strong>Dictionary with protein IDs as keys and sequences as
values.</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

<a
href="https://github.com/mtinti/protein_cutter/blob/main/protein_cutter/core.py#L109"
target="_blank" style="float:right; font-size:smaller">source</a>

### xcleave

>  xcleave (sequence:str, protease:str, missed_cleavages:int=0,
>               nme:bool=True)

*Cleave a protein sequence and return peptides with their start
positions.*

Works with any protease defined in protease_dict using regular
expressions. Handles both C-terminal cleavage (e.g., trypsin) and
N-terminal cleavage (e.g., Lys-N, Asp-N) enzymes.

<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 25%" />
<col style="width: 34%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>sequence</td>
<td>str</td>
<td></td>
<td>Protein amino acid sequence to digest.</td>
</tr>
<tr>
<td>protease</td>
<td>str</td>
<td></td>
<td>Protease name from protease_dict.</td>
</tr>
<tr>
<td>missed_cleavages</td>
<td>int</td>
<td>0</td>
<td>Number of allowed missed cleavage sites. Default is 0.</td>
</tr>
<tr>
<td>nme</td>
<td>bool</td>
<td>True</td>
<td>N-terminal methionine excision (NME)</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>list</strong></td>
<td></td>
<td><strong>List of tuples containing start index and peptide
sequence.</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

<a
href="https://github.com/mtinti/protein_cutter/blob/main/protein_cutter/core.py#L96"
target="_blank" style="float:right; font-size:smaller">source</a>

### get_cleavage_sites

>  get_cleavage_sites (sequence:str, protease:str)

*Get the position of proteolytic cleavage sites in a sequence.*

------------------------------------------------------------------------

<a
href="https://github.com/mtinti/protein_cutter/blob/main/protein_cutter/core.py#L176"
target="_blank" style="float:right; font-size:smaller">source</a>

### digest

>  digest (sequence:str, protein_id:str, enzyme:str='trypsin_full',
>              missed_cleavages:int=1, charge_states:list[int]|None=None,
>              mass_range:tuple[float,float]=(800.0, 4000.0),
>              min_pep_length:int=5, max_pep_length:int=35,
>              fixed_mods:dict[str,float]|None=None, sort_by_mass:bool=False)

*Perform in silico digestion of a protein sequence.*

Digests a protein with the specified enzyme and returns a DataFrame
containing peptide information including masses, m/z values for multiple
charge states, and flanking amino acids. Useful for creating digestion
reports, calculating theoretical peptide coverage, and emPAI
calculations.

<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 25%" />
<col style="width: 34%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>sequence</td>
<td>str</td>
<td></td>
<td>Protein amino acid sequence to digest.</td>
</tr>
<tr>
<td>protein_id</td>
<td>str</td>
<td></td>
<td>Protein identifier to include in the output DataFrame.</td>
</tr>
<tr>
<td>enzyme</td>
<td>str</td>
<td>trypsin_full</td>
<td>Enzyme name for digestion. Supported enzymes include
trypsin,<br>lysc, gluc, chymotrypsin, and others from
pyteomics.<br>Default is trypsin.</td>
</tr>
<tr>
<td>missed_cleavages</td>
<td>int</td>
<td>1</td>
<td>Number of allowed missed cleavage sites. Default is 1.</td>
</tr>
<tr>
<td>charge_states</td>
<td>list[int] | None</td>
<td>None</td>
<td>Charge states for m/z calculation. Default is 1 through 6.</td>
</tr>
<tr>
<td>mass_range</td>
<td>tuple</td>
<td>(800.0, 4000.0)</td>
<td>Min and max monoisotopic mass filter in Daltons.<br>Default is 800.0
to 4000.0 Da.</td>
</tr>
<tr>
<td>min_pep_length</td>
<td>int</td>
<td>5</td>
<td>Minimum peptide length to retain. Default is 5.</td>
</tr>
<tr>
<td>max_pep_length</td>
<td>int</td>
<td>35</td>
<td>Maximum peptide length to retain. Default is 35.</td>
</tr>
<tr>
<td>fixed_mods</td>
<td>dict[str, float] | None</td>
<td>None</td>
<td>Fixed modifications as residue to total mass mapping.<br>Default is
Carbamidomethyl on Cys with mass 160.0306 Da.<br>Pass an empty dict for
no modifications.</td>
</tr>
<tr>
<td>sort_by_mass</td>
<td>bool</td>
<td>False</td>
<td>Sort output by monoisotopic mass. Default is False.</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>DataFrame</strong></td>
<td></td>
<td><strong>DataFrame with the following columns:<br><br>- start_index:
Start position in protein sequence (0-based)<br>- end_index: End
position inclusive (0-based)<br>- pep_seq: Peptide sequence<br>-
protein_id: Protein identifier<br>- pep_length: Peptide length<br>-
prev_aa: Previous amino acid or dash at N-terminus<br>- next_aa: Next
amino acid or dash at C-terminus<br>- extended_seq: Sequence with
flanking amino acids<br>- rep_extended_seq: Extended sequence with
parentheses notation<br>- mass_mono: Monoisotopic mass in Daltons<br>-
mz_N: Mass-to-charge ratio for each charge state N</strong></td>
</tr>
</tbody>
</table>

    /opt/hostedtoolcache/Python/3.10.19/x64/lib/python3.10/site-packages/fastcore/docscrape.py:259: UserWarning: potentially wrong underline length... 
    Charge logic (sequence-aware) Drafted / not Implement 
    ----------------------------- in 
    Digest a protein and return identifiable peptide entries for emPAI-like use.
    ...
      else: warn(msg)
    /opt/hostedtoolcache/Python/3.10.19/x64/lib/python3.10/site-packages/fastcore/docscrape.py:259: UserWarning: Unknown section Filters
      else: warn(msg)

------------------------------------------------------------------------

<a
href="https://github.com/mtinti/protein_cutter/blob/main/protein_cutter/core.py#L338"
target="_blank" style="float:right; font-size:smaller">source</a>

### digest_to_empai_set

>  digest_to_empai_set (sequence:str, enzyme:str='trypsin_full',
>                           missed_cleavages:int=0,
>                           mz_range:tuple[float,float]=(200.0, 4000.0),
>                           min_charge:int=1, max_charge_cap:int=6,
>                           min_pep_length:int=5, max_pep_length:int=52,
>                           fixed_mods:dict[str,float]|None=None,
>                           fixed_mod_labels:dict[str,str]|None=None,
>                           basic_residues:Iterable[str]=('K', 'R', 'H'))

*Digest a protein and return identifiable peptide entries for emPAI-like
use.*

Produces Spectronaut-like strings: *PEPTIDE*.z where z is the charge
state, and fixed mods are rendered in the peptide string,
e.g. C\[Carbamidomethyl (C)\].

## Charge logic (sequence-aware) Drafted / not Implement

For each peptide: max_charge_seq = (#K + \#R + \#H) + 1 (N-terminus)
max_charge = min(max_charge_seq, max_charge_cap) charges tested =
\[min_charge .. max_charge\]

<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 25%" />
<col style="width: 34%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>sequence</td>
<td>str</td>
<td></td>
<td></td>
</tr>
<tr>
<td>enzyme</td>
<td>str</td>
<td>trypsin_full</td>
<td></td>
</tr>
<tr>
<td>missed_cleavages</td>
<td>int</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>mz_range</td>
<td>tuple</td>
<td>(200.0, 4000.0)</td>
<td>Min/max m/z window to consider “identifiable”.</td>
</tr>
<tr>
<td>min_charge</td>
<td>int</td>
<td>1</td>
<td>ignore 1+ ?? yes for now</td>
</tr>
<tr>
<td>max_charge_cap</td>
<td>int</td>
<td>6</td>
<td>Global practical cap on charge state (default 5).</td>
</tr>
<tr>
<td>min_pep_length</td>
<td>int</td>
<td>5</td>
<td></td>
</tr>
<tr>
<td>max_pep_length</td>
<td>int</td>
<td>52</td>
<td></td>
</tr>
<tr>
<td>fixed_mods</td>
<td>dict[str, float] | None</td>
<td>None</td>
<td>Residue -&gt; new monoisotopic mass for that residue (fixed
modification).<br>Default is CAM on Cys: {‘C’: 160.0306}.</td>
</tr>
<tr>
<td>fixed_mod_labels</td>
<td>dict[str, str] | None</td>
<td>None</td>
<td>Residue -&gt; Spectronaut-style label to insert into peptide
string.<br>Default is {‘C’: ‘Carbamidomethyl (C)’}.</td>
</tr>
<tr>
<td>basic_residues</td>
<td>Iterable</td>
<td>(‘K’, ‘R’, ‘H’)</td>
<td>Residues counted as basic for charge upper bound (default
K,R,H).</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>set</strong></td>
<td></td>
<td><strong>e.g., {“<em>DVAGAVEFWTDR</em>.2”,
“<em>DASGPAMTEIGEQPWGR</em>.3”, …}</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

<a
href="https://github.com/mtinti/protein_cutter/blob/main/protein_cutter/core.py#L456"
target="_blank" style="float:right; font-size:smaller">source</a>

### collapse_empai_entries

>  collapse_empai_entries (empai_entries:set[str])

*Collapse Spectronaut-like *PEPTIDE*.z entries to stripped peptide
sequences:* - removes leading/trailing underscores - removes charge
annotation - removes modification annotations in brackets

``` python
#HMVLYFPATGNEPVVDGFFFVEGR
```

------------------------------------------------------------------------

<a
href="https://github.com/mtinti/protein_cutter/blob/main/protein_cutter/core.py#L478"
target="_blank" style="float:right; font-size:smaller">source</a>

### fasta_to_peptide_set

>  fasta_to_peptide_set (fasta_path:Union[str,pathlib.Path],
>                            enzyme:str='trypsin_full', missed_cleavages:int=0,
>                            min_pep_length:int=6, max_pep_length:int=52,
>                            show_progress:bool=True)

*Digest all proteins in a FASTA file and return unique peptide
sequences.*

Performs in silico digestion of every protein in a FASTA file and
collects all resulting peptide sequences into a set. Useful for building
canonical peptide databases, checking peptide detectability, or
identifying novel peptides not present in reference proteomes.

<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 25%" />
<col style="width: 34%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>fasta_path</td>
<td>Union</td>
<td></td>
<td>Path to the input FASTA file.</td>
</tr>
<tr>
<td>enzyme</td>
<td>str</td>
<td>trypsin_full</td>
<td>Enzyme name for digestion. Supported enzymes include
trypsin,<br>lysc, gluc, chymotrypsin, and others from
pyteomics.<br>Default is trypsin.</td>
</tr>
<tr>
<td>missed_cleavages</td>
<td>int</td>
<td>0</td>
<td>Number of allowed missed cleavage sites. Default is 0.</td>
</tr>
<tr>
<td>min_pep_length</td>
<td>int</td>
<td>6</td>
<td>Minimum peptide length to include. Default is 5.</td>
</tr>
<tr>
<td>max_pep_length</td>
<td>int</td>
<td>52</td>
<td>Maximum peptide length to include. Default is 52.</td>
</tr>
<tr>
<td>show_progress</td>
<td>bool</td>
<td>True</td>
<td>Display progress bar during processing. Default is True.</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>set</strong></td>
<td></td>
<td><strong>Set of unique peptide sequences from all digested
proteins.</strong></td>
</tr>
</tbody>
</table>

``` python
#peptide_set
```

------------------------------------------------------------------------

<a
href="https://github.com/mtinti/protein_cutter/blob/main/protein_cutter/core.py#L572"
target="_blank" style="float:right; font-size:smaller">source</a>

### flag_proprietary_peptides_from_set

>  flag_proprietary_peptides_from_set (input_path:Union[str,pathlib.Path],
>                                          output_path:Union[str,pathlib.Path],
>                                          uniprot_peptides:set[str], sequence_c
>                                          ol:str='PEP.StrippedSequence',
>                                          new_col_name:str='is_novel',
>                                          sep:str=None,
>                                          show_progress:bool=True)

*Flag peptides as novel based on absence from a reference peptide set.*

Reads a peptide report file and adds a boolean column indicating whether
each peptide is novel (True) or canonical (False). A peptide is
considered novel if it is NOT present in the provided reference set of
UniProt or canonical peptides.

This function is useful for identifying proprietary ORF peptides that
cannot be explained by known protein sequences, supporting evidence
classification in proteomics workflows.

<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 25%" />
<col style="width: 34%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>input_path</td>
<td>Union</td>
<td></td>
<td>Path to input peptide file (TSV or CSV from Spectronaut or
similar).</td>
</tr>
<tr>
<td>output_path</td>
<td>Union</td>
<td></td>
<td>Path for output file with the new flag column added.</td>
</tr>
<tr>
<td>uniprot_peptides</td>
<td>set</td>
<td></td>
<td>Reference set of canonical peptide sequences. Peptides NOT
in<br>this set are flagged as novel. Typically generated
using<br>fasta_to_peptide_set on a UniProt FASTA file.</td>
</tr>
<tr>
<td>sequence_col</td>
<td>str</td>
<td>PEP.StrippedSequence</td>
<td>Column name containing peptide sequences.<br>Default is
PEP.StrippedSequence.</td>
</tr>
<tr>
<td>new_col_name</td>
<td>str</td>
<td>is_novel</td>
<td>Name for the new boolean flag column. Default is is_novel.</td>
</tr>
<tr>
<td>sep</td>
<td>str</td>
<td>None</td>
<td>Field separator. If None, auto-detects based on file
extension<br>where .csv uses comma and other extensions use tab.</td>
</tr>
<tr>
<td>show_progress</td>
<td>bool</td>
<td>True</td>
<td>Display progress bar during processing. Default is True.</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>int</strong></td>
<td></td>
<td><strong>Number of peptides processed.</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

<a
href="https://github.com/mtinti/protein_cutter/blob/main/protein_cutter/core.py#L677"
target="_blank" style="float:right; font-size:smaller">source</a>

### flag_proprietary_from_pg

>  flag_proprietary_from_pg (input_path:Union[str,pathlib.Path],
>                                output_path:Union[str,pathlib.Path],
>                                accession_col:str='PG.ProteinAccessions',
>                                new_col_name:str='is_novel',
>                                uniprot_prefixes:tuple[str,...]=('>fl', '>sp'),
>                                keep_only_novel:bool=True, sep:str=None,
>                                show_progress:bool=True)

*Flag peptides as novel based on protein accession prefixes.*

Reads a peptide report file and adds a boolean column indicating whether
each entry maps exclusively to proprietary ORFs (True) or includes
UniProt entries (False). Identification is based on checking if protein
accessions contain UniProt prefixes like sp or fl.

This function is useful for identifying peptides that provide evidence
specifically for novel or proprietary ORF discoveries rather than known
UniProt sequences.

<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 25%" />
<col style="width: 34%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>input_path</td>
<td>Union</td>
<td></td>
<td>Path to input peptide file (TSV or CSV from Spectronaut or
similar).</td>
</tr>
<tr>
<td>output_path</td>
<td>Union</td>
<td></td>
<td>Path for output file with the new flag column added.</td>
</tr>
<tr>
<td>accession_col</td>
<td>str</td>
<td>PG.ProteinAccessions</td>
<td>Column name containing protein accessions.<br>Default is
PG.ProteinAccessions.</td>
</tr>
<tr>
<td>new_col_name</td>
<td>str</td>
<td>is_novel</td>
<td>Name for the new boolean flag column. Default is is_novel.</td>
</tr>
<tr>
<td>uniprot_prefixes</td>
<td>tuple</td>
<td>(‘&gt;fl’, ‘&gt;sp’)</td>
<td>Prefixes identifying UniProt entries in accession
strings.<br>Default is (‘&gt;fl’, ‘&gt;sp’) for UniProt ORFs and
Swiss-Prot entries.</td>
</tr>
<tr>
<td>keep_only_novel</td>
<td>bool</td>
<td>True</td>
<td>If True, only write rows where is_novel is True to output
file.<br>If False, write all rows with the flag column added.<br>Default
is False.</td>
</tr>
<tr>
<td>sep</td>
<td>str</td>
<td>None</td>
<td>Field separator. If None, auto-detects based on file
extension<br>where .csv uses comma and other extensions use tab.</td>
</tr>
<tr>
<td>show_progress</td>
<td>bool</td>
<td>True</td>
<td>Display progress bar during processing. Default is True.</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>dict</strong></td>
<td></td>
<td><strong>Summary statistics containing:<br><br>- total: Total number
of entries processed<br>- proprietary_only: Entries mapping only to
proprietary ORFs<br>- has_uniprot: Entries with UniProt mappings<br>-
written: Number of lines written to output file</strong></td>
</tr>
</tbody>
</table>

``` python
res
```

    {'total': 10, 'proprietary_only': 9, 'has_uniprot': 1, 'written': 10}

------------------------------------------------------------------------

<a
href="https://github.com/mtinti/protein_cutter/blob/main/protein_cutter/core.py#L829"
target="_blank" style="float:right; font-size:smaller">source</a>

### load_peptides_from_fasta

>  load_peptides_from_fasta (fasta_path:Union[str,pathlib.Path],
>                                show_progress:bool=True)

*Load unique peptide sequences from a FASTA file.*

This function reads a FASTA-formatted file and returns all unique
peptide sequences found in the file. Header lines (those starting with
`>` ) are ignored, and each non-empty sequence line is treated as a
complete peptide.

<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 25%" />
<col style="width: 34%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>fasta_path</td>
<td>Union</td>
<td></td>
<td>Path to the FASTA file containing peptide sequences.</td>
</tr>
<tr>
<td>show_progress</td>
<td>bool</td>
<td>True</td>
<td>If <code>True</code>, print progress messages indicating loading
status<br>and the number of unique peptides loaded.</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>set</strong></td>
<td></td>
<td><strong>A set containing unique peptide sequences extracted from
the<br>FASTA file.</strong></td>
</tr>
</tbody>
</table>
